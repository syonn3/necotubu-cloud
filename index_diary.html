<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Neco-Tubu つぶやき</title>
    <style>
      :root{
        --bg:#1c1a17; --surface:#2a211b; --card:#3b3128; --ink:#f5f1e6; --muted:#cbae82;
        --primary:#ff7f32; --accent:#a3c586; --line:#53473f; --shadow:0 3px 12px rgba(0,0,0,.35);
        --r:14px; --danger:#8d3a3a; --disabled:.45;
      }
      *{box-sizing:border-box}
      html,body{margin:0;background:var(--bg);color:var(--ink);
        font-family:-apple-system,BlinkMacSystemFont,"Hiragino Kaku Gothic ProN","Noto Sans JP","Meiryo",sans-serif;line-height:1.6}
      a{text-decoration:none;color:inherit}
      header{position:sticky;top:0;z-index:10;background:var(--card);border-bottom:1px solid var(--line);
        box-shadow:var(--shadow);padding:12px 14px}
      header .bar{max-width:720px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
      header h1{margin:0;font-size:18px;color:var(--primary)}
      .btn{display:inline-block;padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:var(--accent);
        color:#1c1a17;cursor:pointer;transition:.15s}
      .btn.primary{background:var(--primary);color:#fff;border-color:var(--primary)}
      .btn.disabled{opacity:var(--disabled);cursor:not-allowed;pointer-events:none;filter:grayscale(60%)}
      main{max-width:720px;margin:0 auto;background:var(--surface);min-height:100vh;padding:16px 12px 24px}
      .card{background:var(--card);border:1px solid var(--line);border-radius:var(--r);padding:14px;margin:16px 0;box-shadow:var(--shadow)}
      .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
      .right{justify-content:flex-end}
      .hint{color:var(--muted);font-size:12px}
      .avatar{width:80px;height:80px;border-radius:50%;overflow:hidden;border:2px solid var(--line);
        display:flex;align-items:center;justify-content:center;background:#6a6159;color:#fff;font-weight:800;font-size:22px}
      .avatar img{width:100%;height:100%;object-fit:cover}
      .profile p{margin:2px 0}
      .tw{font-size:16px;line-height:1.8;white-space:pre-wrap}
      input[type=file]{position:absolute;left:-9999px;width:1px;height:1px;opacity:0}
      .snap-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
      .snap{position:relative;border-radius:12px;overflow:hidden;border:1px solid var(--line);box-shadow:var(--shadow);background:#000}
      .snap img{width:100%;height:100%;display:block;object-fit:cover}
      .snap .del{position:absolute;top:6px;right:6px;padding:6px 8px;border:none;border-radius:10px;background:var(--danger);color:#fff;cursor:pointer}
      @media (max-width:480px){ .snap-grid{grid-template-columns:repeat(2,1fr);} }
      #cat-name, .card h2 { color: var(--primary); }
      .error-box{display:none;margin-top:8px;padding:10px 12px;border:1px solid #7a3a3a;background:#3b2727;color:#ffd4d4;border-radius:10px}
    </style>
  </head>
  <body>
    <header>
      <div class="bar">
        <h1>Neco-Tubu つぶやき</h1>
        <a href="index_home.html" class="btn">HOME</a>
      </div>
    </header>

    <main>
      <!-- プロフィール -->
      <section id="cat-profile" class="card">
        <div class="row">
          <div class="avatar" id="cat-avatar">？</div>
          <div class="profile">
            <p id="cat-name" style="font-weight:700;font-size:18px">ネコ</p>
            <p id="cat-gender" class="hint">性別: -</p>
            <p id="cat-age" class="hint">年齢: -</p>
            <p id="cat-breed" class="hint">猫種: -</p>
            <p id="cat-personality" class="hint">性格: -</p>
            <p id="cat-fav" class="hint">特徴: -</p>
            <p id="cat-territory" class="hint">テリトリー: -</p>
          </div>
        </div>
        <div class="row right" style="margin-top:10px">
          <a href="index_cats.html" class="btn">ほかのネコ</a>
          <a href="index_calendar.html" class="btn">カレンダー</a>
        </div>
      </section>

      <!-- つぶやき -->
      <section class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div>
            <h2 id="tw-title" style="margin:0 0 8px 0">つぶやき</h2>
            <p id="tw-date" style="font-weight:600;margin:0 0 6px 0"></p>
            <!-- ★開発用の速度表示（dev環境のみ表示） -->
            <p id="tw-perf" class="hint" style="display:none;margin:0"></p>
          </div>
          <button id="btn-regen" class="btn">もう１回聴く</button>
        </div>
        <p id="tw-loading" class="hint">つぶやきに聞き耳を立てています‥</p>
        <div id="tw-body" class="tw" style="display:none"></div>
        <div id="tw-error" class="error-box"></div>
      </section>

      <!-- スナップ -->
      <section class="card">
        <div class="row" style="justify-content:space-between;align-items:center">
          <h2 style="margin:0">スナップ</h2>
          <div class="row">
            <label for="snap-file" class="btn">写真を追加</label>
            <input id="snap-file" type="file" accept="image/*">
          </div>
        </div>
        <div id="snap-grid" class="snap-grid" style="margin-top:10px"></div>
        <p class="hint">選ぶと自動で縮小保存（長辺1200px）。端末内のローカル保存です。</p>
      </section>

      <!-- SNS -->
      <section class="card">
        <h2 style="margin:0 0 8px 0">SNSシェア</h2>
        <div class="row">
          <button id="btn-fb" class="btn">Facebook</button>
          <button id="btn-ig" class="btn">Instagram</button>
          <button id="btn-tt" class="btn">TikTok</button>
          <button id="btn-x" class="btn">X</button>
        </div>
        <p class="hint">※スナップが無いときはシェアできません。</p>
      </section>
    </main>

    <script src="js/config.js"></script>
    <script src="js/api.js"></script>
    <script src="js/snaps.js"></script>

    <script>
      (function(){
        /* ====== 定数・ユーティリティ ====== */
        const CATS_KEY='necotubu_cats';
        const NS=(window.APP_CONFIG&&window.APP_CONFIG.STORAGE_NS)||'necotubu_v1';
        const HOME_NOTE   = NS+':home:note';
        const HOME_GENDER = NS+':home:gender';
        const HOME_WEATH  = NS+':home:weather';
        const HOME_DATE   = NS+':home:date';
        const HOME_OWNER_CALL = NS+':home:ownerCall'; // index_register.html 側で設定、ここでは読むだけ
        const TWEET_MAX = 320;

        function qs(){ return new URLSearchParams(location.search||''); }
        function clamp(txt,max){ const s=String(txt||''); return s.length<=max?s:s.slice(0,max-1)+'…'; }
        function todayJST(){ const now=new Date(); return new Date(now.toLocaleString('ja-JP',{timeZone:'Asia/Tokyo'})); }
        function yobi(n){ return '日月火水木金土'.charAt(n%7); }
        function weatherEmoji(w){ return ({sunny:'☀',cloudy:'☁',rain:'☂',snow:'❄',storm:'⚡'}[w]||''); }
        function toDate(y,m,d){ if(!y||!m||!d) return null; const dt=new Date(+y,+m-1,+d); return isNaN(dt)?null:dt; }
        function yearsBetween(a,b){ if(!a||!b) return null; return (b-a)/(365.25*24*3600*1000); }
        function monthsBetween(a,b){ if(!a||!b) return null; return Math.max(0, Math.floor((b-a)/(30*24*3600*1000))); }
        function firstChar(s){ s=String(s||'').trim(); return s? s[0]:'？'; }
        function colFor(str){ const AVA=['#7E5A3C','#6B7A40','#AD6A3B','#5E5347','#8C7448','#7A614C','#9A6E4D']; let h=0; str=String(str||''); for(let i=0;i<str.length;i++)h=(h*31+str.charCodeAt(i))|0; return AVA[Math.abs(h)%AVA.length]; }
        function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

        function sanitize(t){
          return String(t||'')
            .replace(/にゃん?|ﾆｬ|ﾆｬﾝ|ニャン/gi,'')
            .replace(/\d{1,2}月\d{1,2}日/g,'きょう')
            .replace(/\b\d{1,2}:\d{2}\b/g,'')
            .replace(/(月曜|火曜|水曜|木曜|金曜|土曜|日曜)/g,'')
            .trim();
        }
        function dedupeEndings(s){
          let out=s;
          out=out.replace(/(だよ|だね|なの|かな)([よねのー〜]+)(?=。|！|？|$)/g,'$1');
          out=out.replace(/(よ|ね|の)+(だよ|だね|なの|かな)/g,'$2');
          out=out.replace(/(だよ|だね|なの|かな)。(?:\s*)(だよ|だね|なの|かな)。(?!\S)/g,'$1。');
          return out;
        }

        /* ====== やわらか化：共通仕上げロジック（語尾判定拡張） ====== */
        const SOFT_OK_RE = /(だよね|だよ|かな|かもね|んだよね|んだ|ないよ|いいんだ|かぁ|だぁ)$/;
        const VERBISH_RE = /(ておく|ていく|てくる|てみる|ちゃう|じゃう|しまう|できる|られる|れる|える|てる|ている|たい|たくなる|やすい|にくい|づらい|なる|する|いる|ある|いく|くる|おく|できた|なった|した|いった|きた)$/;
        const BASE_END_RE = /(る|た|う|く|す|つ|む|ぶ|ぬ|ぐ)$/;
        function finalizeSoftEnding(seg, gender){
          const tail=(seg.match(/[。！？]+$/)||[''])[0];
          let core=seg.slice(0, seg.length - tail.length);
          if(!core) return seg;

          // すでに柔らかければ触らない
          if(SOFT_OK_RE.test(core)) return seg;

          // 丁寧語→やわらか
          core = core.replace(/です$/,'だよ').replace(/ます$/,'だよ');

          // 名詞＋だ/です
          if(/(だ|です)$/.test(core)){
            core = core.replace(/です$/, (gender==='female'?'だよね':'だよ'))
                       .replace(/だ$/,   (gender==='female'?'だよね':'だよ'));
            return core + tail;
          }

          // 動詞・形容詞っぽい終わり
          if(VERBISH_RE.test(core) || BASE_END_RE.test(core)){
            core += (gender==='female' ? 'んだよね' : 'んだ');
            return core + tail;
          }

          // 形容詞（〜い）※否定の「ない」は別
          if(/[^な]い$/.test(core)){
            core += (gender==='female' ? 'んだよね' : 'んだ');
            return core + tail;
          }

          return core + tail;
        }

        /* ====== やわらか化（強） ====== */
        function adjustToneByGenderAge(text, gender, ageMonths, persona){
          let s=String(text||''); if(!s) return s;
          const g=(gender==='male')?'male':(gender==='female'?'female':'other');
          const m=Math.max(0, Number(ageMonths)||0);
          const strength = m<12 ? 0.25 : (m<24 ? 0.50 : 0.85);
          const softer = (g==='female')? ['だよね','かな','かもね','だよ','んだよね','んだ']
                        : (g==='male')  ? ['だよ','だよね','かな','かもね','んだ','んだよね']
                        : ['だよ','かな','かもね','んだ'];

          const parts=s.split(/(?<=[。！？])/);
          function tweak(seg){
            if(!seg) return seg;
            let out=seg;
            if(Math.random()<=strength){
              // 硬い言い回しをまず置換
              out = out
                .replace(/なのだ(?=([。！？」』]|$))/g, randPick(['なんだよね','なんだよ','なんだ']))
                .replace(/である(?=([。！？」』]|$))/g, randPick(softer))
                .replace(/だが(?=([、。！？」』]|$))/g, 'けど')
                .replace(/だと思う(?=([。！？」』]|$))/g, randPick(['気がする','かも']))
                .replace(/だろう(?=([。！？」』]|$))/g, randPick(['かも','かな']))
                .replace(/だな(?=([。！？」』]|$))/g, randPick(softer))
                .replace(/だぞ(?=([。！？」』]|$))/g, randPick(softer));
            }
            // 最終ふんわり（拡張判定）
            out = finalizeSoftEnding(out, gender);
            return out;
          }
          return parts.map(tweak).join('');
        }

        // クール以外はさらに硬さを下げる
        function softenHardEndings(text, persona, gender){
          let s=String(text||''); if(!s) return s;
          const cool = (persona==='cool');
          const keepRate = cool ? 0.20 : 0.02; // ほぼ置換
          function maybe(re, rep){
            s = s.replace(re, (m)=> (Math.random()<keepRate ? m : (typeof rep==='function'? rep(): rep)));
          }
          const soft = (gender==='female') ? ()=>randPick(['だよね','だよ','かな','んだよね'])
                                           : (gender==='male')   ? ()=>randPick(['だよ','だよね','かな','んだ'])
                                                                 : ()=>randPick(['だよ','かな','んだ']);

          maybe(/なのだ(?=([。！？」』]|$))/g, ()=> randPick(['なんだよね','なんだよ','なんだ']));
          maybe(/である(?=([。！？」』]|$))/g, ()=> soft());
          maybe(/だが(?=([、。！？」』]|$))/g, 'けど');
          maybe(/だと思う(?=([。！？」』]|$))/g, ()=> randPick(['気がする','かも']));
          maybe(/だろう(?=([。！？」』]|$))/g, ()=> randPick(['かも','かな']));

          // 硬い単語をやわらげ
          s = s.replace(/思案する/g, randPick(['考えちゃう','迷っちゃう']))
               .replace(/心象/g, 'きぶん')
               .replace(/結局、/g, randPick(['それで、','じゃあ、']))
               .replace(/ことにした(?=([。！？」』]|$))/g, randPick(['ことにしたよ','にしようかな']));

          // 文単位で最終ふんわり（拡張判定）
          s = s.split(/(?<=[。！？])/).map(seg=> finalizeSoftEnding(seg, gender)).join('');
          return s;
        }

        /* ====== 野良の表現補正 ====== */
        function fixStrayPhrases(text){
          let s=String(text||''); if(!s) return s;
          s = s.replace(/(飼い主|ご主人|主人|おうちの人|家の人)/g, '人');
          s = s.replace(/窓辺/g, '塀のうえ')
               .replace(/窓の外/g, '空のほう')
               .replace(/部屋/g, '路地')
               .replace(/膝の上/g, 'そば')
               .replace(/ソファ/g, '段ボール')
               .replace(/ベッド/g, 'ひさしの影')
               .replace(/カーテン/g, '看板の影');
          return s;
        }

        // 野良×甘え：つかずはなれずの甘えを1つは入れる
        function ensureStrayAffection(text, persona, territory, ageMonths){
          let s=String(text||''); if(!s) return s;
          const terr=String(territory||'').toLowerCase();
          if(terr!=='stray') return s;
          const hasCue = /(しっぽ|尻尾|耳を|耳だけ|のど|喉|ごろ|すり|すっと|そば|近づ|丸く|足もと|足元|鳴|小さく|ゆっくり瞬き)/.test(s);
          if(hasCue) return s;
          const m=Math.max(0, Number(ageMonths)||0);
          const strength = (persona==='clingy') ? (m<12?0.6:0.9) : 0.35;
          if(Math.random()>strength) return s;
          const candidates = [
            '少し距離をあけつつ、しっぽをそっと立てて合図してみたよ',
            '耳だけ向けて「ここにいるよ」と伝えてみた',
            '足もとで小さくまとまって、安心のしるしだけ置いておく',
            'のどを小さく鳴らして、近いけど近づきすぎない感じにした',
            'すりっと一歩だけ寄って、様子をうかがう',
            '視線を合わせてから、ゆっくり瞬きであいさつした'
          ];
          const add = randPick(candidates);
          if((s.length + add.length + 1) <= TWEET_MAX) s = s.replace(/\s*$/, '') + (s.endsWith('。')?'':'。') + add + '。';
          return s;
        }

        /* ====== 「特徴」を前面に：前半へ自然に差し込み ====== */
        function ensureFeatureMentionFront(text, features){
          let s=String(text||''); if(!s) return s;
          const raw=String(features||'').trim();
          if(!raw || raw==='-' ) return s;
          const tokens = raw.split(/[、,・／\/\s]+/).filter(Boolean).slice(0,2);
          if(tokens.length===0) return s;
          const found = tokens.some(t => s.includes(t));
          if(found) return s;
          const key = randPick(tokens);
          const variants = [
            `${key}を見ると落ち着くんだ`,
            `${key}はちょっと自慢でね`,
            `じつは${key}がチャームポイントなんだよ`,
            `${key}のおかげで元気が出るんだ`
          ];
          const add = randPick(variants);
          const parts = s.split(/(?<=[。！？])/);
          const pos = Math.min(1, parts.length-1);
          const candidate = (parts.slice(0,pos+1).join('') + (add.endsWith('。')?add:add+'。') + parts.slice(pos+1).join(''));
          if(candidate.length<=TWEET_MAX) return candidate;
          const add2 = `${key}はちょっと自慢でね。`;
          if((s.length + add2.length) <= TWEET_MAX) return s + add2;
          return s;
        }

        /* ====== 主人言及：頻度1/3・固定フレーズ回避・ネガは必ず寄りそう ====== */
        function ownerPhraseDejavuParaphrase(seg){
          return seg.replace(/(「)?[^」]*どう出る[^」]*?(」)?/g, randPick([
            '声だけ流れていった',
            '考えごとの気配がした',
            '小さく笑ったみたいに聞こえた',
            '様子を見るのかなって感じ'
          ]));
        }
        function sentenceHasOwner(seg, words){
          return words.some(w => seg.includes(w));
        }
        function textHasOwner(s, words){
          return sentenceHasOwner(s, words);
        }
        function lastOwnerMentionCount(catId, words, n=2){
          try{
            const box = JSON.parse(localStorage.getItem(`${NS}:tw:${catId}`)||'{}');
            const list = Object.values(box).filter(v=>v&&v.text).sort((a,b)=>(a.ts||0)-(b.ts||0));
            const last = list.slice(-n);
            let cnt=0;
            for(const v of last){ if(textHasOwner(String(v.text||''), words)) cnt++; }
            return cnt;
          }catch(_){ return 0; }
        }
        function limitAndParaphraseOwnerMention(text, ownerLabel, isOwnerNegative, territory, histCount){
          let s=String(text||''); if(!s) return s;
          const terr = String(territory||'').toLowerCase();
          const ownerWords = (()=>{
            if(terr==='stray') return ['人','おじちゃん','おねえさん'];
            const base = ['お父さん','お母さん','パパ','ママ','とうさん','かあさん','おとう','おかあ','ごしゅじん','おうちのひと'];
            if(ownerLabel && !base.includes(ownerLabel)) base.unshift(ownerLabel);
            return base;
          })();

          let sentences = s.split(/(?<=[。！？])/).filter(Boolean);
          let anyOwner=false;
          for(let i=0;i<sentences.length;i++){
            let seg=sentences[i];
            const hadOwner = sentenceHasOwner(seg, ownerWords);
            if(!hadOwner) continue;
            anyOwner=true;

            seg = ownerPhraseDejavuParaphrase(seg);

            if(isOwnerNegative){
             
